---

layout:     post
title:      6.s081操作系统学习笔记之lab1
subtitle:   
date:       2021-08-23
author:     Wang.YS
header-img: 
catalog: true
tags:
    - 计算机基础知识学习
    - 操作系统
    - 6.s081

---

# 6.s081操作系统lab1

## 6.s081(2020)简单介绍

[6.s081](https://pdos.csail.mit.edu/6.S081/2020/schedule.html)是MIT的一门本科生操作系统课程。这门课程通过实现一个RISC-V操作系统xv6中的各种功能来给大家展示现代操作系统的一些特点，十分硬核。推荐大家学习，主要用到的编程语言是C语言。接下来就通过之前完成的lab来记录下学习过程中遇到的问题以及心得吧。

## sleep

第一个需要完成的程序非常简单，就是利用atoi函数将输入的参数转换为数字，并调用系统函数sleep进行休眠。具体代码如下

```C
#include "kernel/types.h"
#include "user/user.h"
int
main(int arg, char *argv[]) {
	if (arg != 2) {
		printf("erro input\n");
		exit(1);
	}
	int tick = atoi(argv[1]);
	sleep(tick);
	exit(0);
}
```

## pingpong

第二个部分是利用系统的管道机制创建两个进程进行通信，需要用到的系统函数是pipe以及fork，要求子进程对父进程传递一个bit，然后打印进程id，输出“received ping”，并传递一个bit信息给子进程;同样的，子进程接受父进程的bit，打印进程id，输出“received pong”，输出内容：

```
$ make qemu
...
init: starting sh
$ pingpong
4: received ping
3: received pong
$
```

首先我介绍下xv6的pipe机制，pipe是一个内存缓冲区，可以存放一定数据量的数据用于管道两端进行通信，一般是用于有血缘关系的进程，一端读，另一段写入。所以它具有以下特点：

- 不能用于自己读写，并不是说这样代码会报错，而是自己读写这种方式没有意义
- 它是I/O阻塞的，当管道中无数据，读端会阻塞，当管道中数据写满，写端会阻塞
- 当数据被读走，管道中数据就不存在了
- 当写端关闭，读端调用read会返回0

然后就是fork函数，fork函数作用是创造一个子进程，拥有和父进程相同的变量空间，但是子进程中变量的改变，并不会影响父进程，这个创建过程是对父进程的一种深度拷贝。

- 对父进程空间的拷贝
- 在进程中调用fork()，返回值是进程的id，其中父进程返回自己的进程id，子进程返回0

结合pipe，我们可以将，创建的通道直接利用fork机制，一端拥有读，一端拥有写，从而进行通信，由于子、父进程在题目要求中均需要实现读、写功能，所以我们需要创建两个管道，分别进行通信。

```C
#include "kernel/types.h"
#include "user/user.h"
int main(int agrc, char *argv[]) {
	int p1[2];
	int p2[2];
	pipe(p1);
	pipe(p2);
	char buf[1];
	int pid;
	if ((pid = fork()) == 0) {
		close(p1[0]);
		close(p2[1]);
		if (read(p2[0], buf, 1) == 1) {
		close(p2[0]);
		printf("%d: received ping\n", pid);
		write(p1[1], buf, 1);
		close(p1[1]);
		}
	} else {
		close(p1[1]);
		close(p2[0]);
		write(p2[1], buf, 1);
		close(p2[1]);
		if (read(p1[0], buf, 1) == 1) {
			close(p1[0]);
			printf("%d: received pong\n", getpid());
		}

	}
	exit(0);
}
```



![ ](https://github.com/knightand/knightand.github.io/blob/main/img/Screen%20Shot%202021-07-25%20at%2013.46.02.png?raw=true)



