---
layout:     post
title:      CS61B数据结构之队列(proj1)
subtitle:   
date:       2021-07-25
author:     Wang.YS
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 计算机基础知识学习
    - 数据结构


---

# 队列

proj1主要是考察对队列的理解和使用。什么是队列呢？队列就是一种具有先进先出的特点的数据结构，它一般用于描述下图这样的模型，某个系统提供一种服务，被我组织的数据满足一种顺序，先到达的先进行服务，后到达的后进行服务。

![](https://github.com/knightand/knightand.github.io/blob/main/img/image-20210725190849269.png?raw=true)

在CS61B中这种队列结构主要抽象了以下几种方法：

```java
public void addFirst(T item)
public void addLast(T item)
public boolean isEmpty():
public int size()
public T removeFirst()
public T removeLast()
public T get(int index)
```

## 链表实现队列

首先，我们要实现对一个队列从尾端插入，从首端删除。在这种结构下，需要保证从尾端能够快速插入一个元素，我们的队列里必须保存这个尾端元素，而我们还需要对这个队列进行添加，所以需要保存它的首端元素。

```java
private Node head;
private Node end;
private int size;
```

从上面的描述可以看出，只要使用单向链表就可以完成上述功能，但是针对CS61B，我们要对首尾端同时实现添加和删除功能，所以我们要采用双端链表结构。

```java
private class Node {
    private T value;
    private Node next;
    private Node pre;
    public Node(T value, Node next, Node pre) {
        this.value = value;
        this.next = next;
        this.pre = pre;
    }
}
```

以`removeLast()`方法为例，由于这里同时保存了链表的头尾，注意当队列大小为0和1是边界条件，当队列大小为1，这里头节点和尾节点内容相同。

```java
    public T removeLast() {
      	Node removeNode = end;
				if (size == 0) {
          return null;
        } else if (size == 1) {
          head = null;
          end = null;
          size = 0;
          return removeNode.value;
        }
        end = end.pre;
        end.next = null;
        size--;
        return removeNode.value;
    }
```

同样`addFirst()`方法存在边界条件，`addLast()`和`addFirst()`内容相似。下面简单展示`addFirst()`代码：

```java
public void addFirst(T value) {
    head = new Node(value, head, null);
    size++;
    if (size == 1) {
        end = head;
    } else {
        head.next.pre = head;
    }
}
```

## 循环数组实现队列

由于我们对队列会使用插入和删除操作，作为数组实现队列，很容易明白是不可能把队列的头和尾放在一个固定的位置，它是不断动态变化的。

![image-20210728112028357](https://github.com/knightand/knightand.github.io/blob/main/img/image-20210728112028357.png?raw=true)

上面这个图可以看成一个环，他的head和end在不断动态变化，这也是我们为什么称它为循环数组的原因。在实现这个结构时，由于它的头尾节点不断变化，所以同样需要两个整数描述它的头尾位置。

```java
private int size;
private T[] array;
private int head;
private int end;
private static final int MINSIZEOFDEQUE = 10;
```

数组实现和链表实现还有一个不同是数组需要考虑size和数组大小的关系，这里采取这样一种原则，如何数组大小大于队列长度两倍，那么数组大小缩减一半，如果数组大小等于队列长度，那么数组扩大一倍。

```java
private void resize() {
    int pos = head;
    if ((array.length > MINSIZEOFDEQUE && array.length > 2 * size) || array.length == size) {
        T[] newArray = (T[]) new Object[2 * size];
        for (int i = 0; i < size; i++) {
            if (pos >= array.length) {
                pos = pos - array.length;
            }
            newArray[i] = array[pos];
            pos++;
        }
        array = newArray;
        head = 0;
        end = size - 1;
    }
}
```

## 总结

队列是一种用于具有优先顺序数据的组织方式，它不能用来做查询这样的操作



